# 進め方

Step1 : 問題を解く。

Step2 : 他の人のPRを参照し、コメントする。

Step3 : 3回続けてエラーが出ないように書く。ドキュメントを参照する。

# 実践

## Step1

### 思考ログ

分からないので答えを見る

https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0

https://github.com/olsen-blue/Arai60/pull/29

手作業で考えてみる。

まずpreorderのnodeをとる

inorderでnodeを探して、木を分割する。

これを繰り返す。

preorderって深さ優先なのか、勝手に幅だと思っていた。

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        val_to_index = {}
        for i, val in enumerate(inorder):
            val_to_index[val] = i

        pre_index = 0
        num_nodes = len(preorder)
        def helper(left, right):
            nonlocal pre_index
            if pre_index >= num_nodes:
                return None
            if left > right:
                return None
            val = preorder[pre_index]
            node = TreeNode(val)
            pre_index += 1
            position = val_to_index[val]
            node.left = helper(left, position-1)
            node.right = helper(position+1, right)
            return node
        return helper(0, num_nodes-1)
```

## Step2

### 同じ問題を解いた人のプルリクを見る

https://github.com/SuperHotDogCat/coding-interview/pull/43

- 副作用のある関数
    - 副作用のある関数は参照透過性がなくテストしにくいのは知っていたが、思っている以上に避けたほうがよさそう。

https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0

- https://discord.com/channels/1084280443945353267/1247673286503039020/1300957861614063616
    - inorderでの構築もできる。発想が理解できない。
- https://discord.com/channels/1084280443945353267/1251052599294296114/1265248408076161106
    - numpyはビューを返す
        - https://stackoverflow.com/questions/3485475/can-i-create-a-view-on-a-python-list
        - スライスがO(k)かかることが分かっていることの重要性が分かった気がする
        

### inorderで解く

詰まったのでAIにinorderの解き方をPythonで書いてもらった

preorder_position[back.val] < node_positionだとnode.leftにはならなそう

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preorder_position = {val: i for i, val in enumerate(preorder)}
        stack: List[TreeNode] = []

        def gather_descendants(node_position: int) -> Optional[TreeNode]:
            child = None
            while stack:
                back = stack[-1]
                if preorder_position[back.val] < node_position:
                    break
                stack.pop()
                back.right = child
                child = back
            return child

        for i in inorder:
            node = TreeNode(i)
            node_position = preorder_position[node.val]
            node.left = gather_descendants(node_position)
            stack.append(node)

        return gather_descendants(float('-inf'))
```

https://github.com/goto-untrapped/Arai60/pull/53#discussion_r1780608187

手作業で確認してみて、以下は言えそう

inorderのみの場合はindexがA<Bなら、AはBの左側にあるのはわかるが、AはBの左上なのか、左下なのかを特定できない。

preorderのみの場合は、indexがA<Bなら、AはBの子でないことはわかるが、違う部分木に属しているのか、Bを子に持つかがわからない。

組み合わせれば確かに一意になりそうな気はする。

## Step3

### 3回連続で再現できるようになる

正直あまり理解できていないが、時間をかけすぎているので次に進む

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        val_to_preorder_i = {val : i for i, val in enumerate(preorder)}
        stack = []
        def gather_descendants(ancestor_index):
            child = None
            while stack:
                node = stack[-1]
                if val_to_preorder_i[node.val] < ancestor_index:
                    break
                stack.pop()
                node.right = child
                child = node
            return child
        
        for val in inorder:
            node = TreeNode(val)
            index = val_to_preorder_i[val]
            node.left = gather_descendants(index)
            stack.append(node)
        return gather_descendants(-math.inf)
```
