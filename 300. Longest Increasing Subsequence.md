# 進め方

Step1 : 問題を解く。

Step2 : 他の人のPRを参照し、コメントする。

Step3 : 3回続けてエラーが出ないように書く。ドキュメントを参照する。

# 実践

## Step1

### 思考ログ

スタート、しっぽ、カウントを持てば出せそうな気がした

WA 

nums =[0,1,0,3,2,3] で間違い。カウントだけ持つのが間違いな気がする。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        candidates = []
        candidates.append((nums[0], nums[0], 1))
        max_count = 1
        max_count_tail = nums[0]
        for num in nums[1:]:
            print(candidates)
            next_candidates = []
            for head, tail, count in candidates:
                if count < max_count and tail > max_count_tail:
                    continue 
                if num > tail:
                    count += 1
                    if count > max_count:
                        max_count = count
                        max_count_tail = num
                    next_candidates.append((head, num, count))
                    continue
                if num == tail:
                    next_candidates.append((head, tail, count))
                    continue
                # num < tail
                if num < head:
                    next_candidates.append((num, num, 1))
                    continue
                next_candidates.append((head, tail, count))
            candidates = next_candidates
        return max_count
```

## Step2

### 同じ問題を解いた人のプルリクを見る

https://github.com/olsen-blue/Arai60/pull/31/files

- 動的計画法、二分探索の解き方がある。

動的計画法

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        len_nums = len(nums)
        max_lengths = [1] * len_nums
        for i in range(len_nums):
            for j in range(i):
                if nums[j] < nums[i]:
                    max_lengths[i] = max(max_lengths[i], max_lengths[j] + 1)
        return max(max_lengths) 
```

二分探索

https://docs.python.org/ja/3.13/library/bisect.html

このコメントが分かりやすかった。

> あ、なるほど。数字を差し替えても長さ変わらないし、筋の良さげなルートをキープしておいて、未来において、より長いLISが作れる可能性を最大化しましょうということなのね、と理解。
> 
> - なんか、鞍替えの準備をしっかり進めていて、抜け目がなくて、用意周到ですねぇ。一途ではなく浮気的とも言えるかもしれません。(感情の備忘として敢えてこう書きました。感情を持った方が頭に残ることが多いため。)
> - 「1, 98, 99, 100, 2, 4」に対して、仮に「5, 6」と続いたら、キープしておいたルートが生きるわけですね。恐れ入りました。
> 
> ```
>     1 ─ 98 ─ 99 ─ 100
>       └─ 2 ─  4 -  5 -  6
> 
> ```
> 

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lis = [] # 長さがインデックスの increasing sequence を作る場合の末尾の最小値
        for num in nums:
            i = bisect_left(lis, num)
            if i == len(lis):
                lis.append(num)
            else:
                lis[i] = num
            print(lis)
        return len(lis)
```

https://discord.com/channels/1084280443945353267/1200089668901937312/1209563502407065602

変数名について

- https://discord.com/channels/1084280443945353267/1200089668901937312/1209882689411223644

> ループを出たら忘れ去られていいような変数は、1文字変数で構わないと思います。ループを出てもそっから大事な役割を果たすならば、こいつは覚えておいて欲しいと、代入して名前を付け替えたりしましょう。

他、その関数内での主役となる変数なんだったら、一単語か二単語くらいで、名前がついて欲しいです。
関数は、読んだら何が起きるか中身を見なくてもだいたい知りたいじゃないですか。だから、名前は長めになります。
DP の場合は、それがなんなのかを周辺から理解していかないといけないんですよね。なので、長くてもいいだろうと思います。まあ、それかコメント書いておくかですね。

ローカル変数だと、そんなに真面目に長く説明しなくてもいいけれども、グローバルな関数だと、別のファイルを読んでいるときに中身を読まずに中身を推測したいので長く書くでしょう。6単語くらいは普通じゃないですか。

あと、変数名が長くても本来は自動インデントなどでもうちょっと読みやすくなるのでは。
> 

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        max_lis_lengths = [1] * len(nums)
        def get_max_length_before_i(index):
            max_length = 0
            for j in range(index):
                if nums[j] < nums[index]:
                    max_length = max(max_length, max_lis_lengths[j]) # ここで+ 1してWA
            return max_length
        
        for i in range(len(nums)):
            max_lis_lengths[i] = get_max_length_before_i(i) + 1
        return max(max_lis_lengths)
```

これとても分かりやすい

## Step3

### 3回連続で再現できるようになる
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        max_lengths_before_i = [1] * len(nums)
        def get_max_length_before_i(index):
            max_length = 0
            for target in range(index):
                if nums[target] < nums[index]:
                    max_length = max(max_length, max_lengths_before_i[target])
            return max_length
        
        for i in range(len(nums)):
            max_lengths_before_i[i] = get_max_length_before_i(i) + 1
        return max(max_lengths_before_i)
```

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        max_increasing_lengths_before_i = [1] * len(nums)
        def get_max_increasing_lengths_before_i(index):
            max_length = 0
            for target in range(index):
                if nums[target] < nums[index]:
                    max_length = max(max_length, max_increasing_lengths_before_i[target])
            return max_length

        for i in range(len(nums)):
            max_increasing_lengths_before_i[i] = get_max_increasing_lengths_before_i(i) + 1
        return max(max_increasing_lengths_before_i)
```
